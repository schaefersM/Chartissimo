// SLICE NOT SPLICE
//     const chartDispatch = useDispatch()
//     const { charts } = useChartStore();

//     const labelHour = charts[id].data.labels[0].split(":")[0];

//     const testLabels = charts[id].previousHour === "25" ? Array.from(new Array(24), (_, hour) =>
//         hour < 10 ? `0${hour}:00` : `${hour}:00`
//     ) : Array.from(new Array(60), (_, minute) => minute < 10 ? `${labelHour}:0${minute}`: `${labelHour}:${minute}`);

//     const testDatasets = charts[id].data.datasets.map((dataset, _) => {
//         return dataset.data;
//     });

//     const checkDisableHandler = charts[id].data.datasets.map((dataset, _) => {
//         return dataset.data[0];
//     });

//     const minRange = charts[id].copyOfDatasets.map((dataset, _) => {
//         return dataset.data.findIndex((d) => d !== null);
//     });

//     const maxRange = charts[id].copyOfDatasets.map((dataset, _) => {
//         return dataset.data.reverse().findIndex((d) => d !== null);
//     });

//     console.log(charts[id].copyOfDatasets);
//     const reverse = charts[id].data.datasets.map((dataset, _) => {
//         return dataset.data.reverse();
//     });


//     console.log(minRange);
//     console.log(Math.floor(Math.min(...maxRange)/2))
//     console.log(maxRange);

//     const [hours, setHours] = useState(testLabels);
//     const [datasets, setDatasets] = useState(testDatasets);
//     const [prevHour, setPrevHour] = useState(12);

//     // console.log(hours);
//     const handleChange = (e) => {
//         let newHours;
//         let newDatasets;
//         // console.log(`previousHour ${prevHour}`)
//         if (e < prevHour) {
//             newHours = [...hours];
//             newHours.splice(0, 1);
//             newHours.splice(-1, 1);
//             newDatasets = datasets.map((dataset, i) => {
//                 dataset.splice(0, 1);
//                 dataset.splice(-1, 1);
//                 return dataset;
//             })
//             // console.log(newDatasets[0].length);
//             // console.log(newDatasets[0])
//             setDatasets(newDatasets);
//             setHours(newHours);
//         } else {
//             newHours = [];
//             newDatasets = testDatasets.map((dataset, i) => {
//                 dataset.push(null)
//                 dataset.unshift(...testDatasets[i].slice(testDatasets[i].length / 2 - e, testDatasets.length / 2 ));
//                 return dataset;
//             })
//             newHours.push(...testLabels.slice(testLabels.length / 2, testLabels.length / 2 + e));
//             newHours.unshift(
//                 ...testLabels.slice(testLabels.length / 2 - e, testLabels.length / 2)
//             );
//             setHours(newHours);
//             setDatasets(newDatasets);
//         }
//         let newChart = charts[id];
//         newChart = {
//             ...newChart,
//             data: {
//                 ...newChart.data,
//                 labels: newHours
//             },
//         };
//         charts.splice(id, 1, newChart);
//         chartDispatch({ type: "updateChart", payload: charts });
//         setPrevHour(e);
//     };

//     return (
//         <>
//             {checkDisableHandler.includes(null) && 
//             <Slider
//                 min={12-9}
//                 max={12}
//                 startPoint={12}
//                 defaultValue={12}
//                 style={{ width: "25%" }}
//                 onChange={handleChange}
//             />}
//         </>
//     );
// }


// SLICE NOT SPLICE
    const chartDispatch = useDispatch()
    const { charts } = useStore();

    const labelHour = charts[id].data.labels[0].split(":")[0];

    const testLabels = charts[id].previousHour === "25" ? Array.from(new Array(24), (_, hour) =>
        hour < 10 ? `0${hour}:00` : `${hour}:00`
    ) : Array.from(new Array(60), (_, minute) => minute < 10 ? `${labelHour}:0${minute}`: `${labelHour}:${minute}`);

    const testDatasets = charts[id].data.datasets.map((dataset, _) => {
        return dataset.data;
    });

    const checkDisableHandler = charts[id].data.datasets.map((dataset, _) => {
        return dataset.data[0];
    });

    const minRange = charts[id].data.datasets.map((dataset, _) => {
        return dataset.data.findIndex((d) => d !== null);
    });

    const maxRange = charts[id].data.datasets.map((dataset, _) => {
        return dataset.data.reverse().findIndex((d) => d !== null);
    });

    const reverse = charts[id].data.datasets.map((dataset, _) => {
        return dataset.data.reverse();
    });


    console.log(minRange);
    console.log(Math.floor(Math.min(...maxRange)/2))
    console.log(maxRange);

    const [hours, setHours] = useState(testLabels);
    const [datasets, setDatasets] = useState(testDatasets);
    const [prevHour, setPrevHour] = useState(12);

    // console.log(hours);
    const handleChange = (e) => {
        let newHours;
        let newDatasets;
        // console.log(`previousHour ${prevHour}`)
        if (e < prevHour) {
            newHours = [...hours];
            newHours.splice(0, 1);
            newHours.splice(-1, 1);
            newDatasets = datasets.map((dataset, i) => {
                dataset.splice(0, 1);
                dataset.splice(-1, 1);
                return dataset;
            })
            // console.log(newDatasets[0].length);
            // console.log(newDatasets[0])
            setDatasets(newDatasets);
            setHours(newHours);
        } else {
            newHours = [];
            newDatasets = testDatasets.map((dataset, i) => {
                dataset.push(null)
                dataset.unshift(...testDatasets[i].slice(testDatasets[i].length / 2 - e, testDatasets.length / 2 ));
                return dataset;
            })
            newHours.push(...testLabels.slice(testLabels.length / 2, testLabels.length / 2 + e));
            newHours.unshift(
                ...testLabels.slice(testLabels.length / 2 - e, testLabels.length / 2)
            );
            setHours(newHours);
            setDatasets(newDatasets);
        }
        let newChart = charts[id];
        newChart = {
            ...newChart,
            data: {
                ...newChart.data,
                labels: newHours
            },
        };
        charts.splice(id, 1, newChart);
        chartDispatch({ type: "updateChart", payload: charts });
        setPrevHour(e);
    };

    return (
        <>
            {checkDisableHandler.includes(null) && 
            <Slider
                min={12-9}
                max={12}
                startPoint={12}
                defaultValue={12}
                style={{ width: "25%" }}
                onChange={handleChange}
            />}
        </>
    );
}